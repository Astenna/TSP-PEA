/*package main

import (
	"fmt"
	"math/rand"
)

type AdjacencyMatrix struct {
}

func (g AdjacencyMatrix) String() string {
	return fmt.Sprintf("Name: %vSize: %v\nValues: %v", g.Name, g.Size, g.Values)
}

func (g *AdjacencyMatrix) CreateRandomSolution() []int {
	var solution []int
	var notVisitedNodes []int

	for i := 1; i < g.Size; i++ {
		notVisitedNodes = append(notVisitedNodes, i)
	}

	solution = append(solution, 0)

	for len(notVisitedNodes) != 0 {
		nodeToAddIndex := rand.Intn(len(notVisitedNodes))
		solution = append(solution, notVisitedNodes[nodeToAddIndex])
		notVisitedNodes[nodeToAddIndex] = notVisitedNodes[len(notVisitedNodes)-1]
		notVisitedNodes = notVisitedNodes[:len(notVisitedNodes)-1]
	}

	return solution
}

func (g *AdjacencyMatrix) GetCycleFromUser() []int {
	var nodeToAdd int
	var solution []int
	var nodes = map[int]bool{}

	for i := 0; i < g.Size; i++ {
		nodes[i] = false
	}

	for len(solution) < g.Size {
		fmt.Println("Enter node to add to cycle:")
		fmt.Println("Choose one of not visited nodes (false status)")
		fmt.Println(nodes)
		fmt.Scan(&nodeToAdd)
		if !nodes[nodeToAdd] {
			solution = append(solution, nodeToAdd)
			nodes[nodeToAdd] = true
		} else {
			fmt.Println("This node has been already added to the cycle!")
		}
	}
	return solution
}

func (g *AdjacencyMatrix) SolveUsingBruteForce() []int {

}*/
